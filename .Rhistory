warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
}
getModified(plot)
getModified <- function(name, env = parent.frame()) {
if (!is.character(name) & length(name)==1) {
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
}
getModified(plot)
getModified <- function(name, env = parent.frame()) {
if (!is.character(name) & length(name)==1) {
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
}
getModified(plot)
recursiveGet <- function(name, env = parent.frame()) {
stopifnot(is.character(name), length(name) == 1)
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
recursiveGet(name, env = parent.env(env))
}
}
recursiveGet(plot)
getModified <- function(name, env = parent.frame()) {
if (!is.character(name) & length(name)==1) {
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
}
getModified(plot)
getModified <- function(name, env = parent.frame()) {
stopifnot(is.character(name), length(name) == 1) {
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
}
getModified(plot)
getModified <- function(name, env = parent.frame()) {
stopifnot(is.character(name), length(name) == 1)
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
getModified(plot)
is.character(plot)
is.character(plot)==TRUE
is.character(plot)=TRUE
getModified <- function(name, env = parent.frame()) {
if (!is.character(name)) { name <- deparse(substitute(name)) }
if (identical(env, emptyenv())) {
# base case
warning(paste(name," not found"))
NULL
} else if (is.element(name,ls(env))) {
# success case
env[[name]]
} else {
# recursive case
getModified(name, env = parent.env(env))
}
}
getModified(plot)
fget(name, env, inherits = TRUE) {
if (!is.character(name)) { name <- deparse(substitute(name)) }
test <- function(env,name) is.element(name,ls(env)) && is.function(env[[`name`]])
if (test(env,name)) return(env[[`name`]])
if (isTRUE(inherits)) {
while (!identical(env,emptyenv())) {
env <- parent.env(env)
if (test(env,name)) return(env[[`name`]])
}
}
warning(paste(name," not found"))
NULL
}
fget<- function(name, env, inherits = TRUE) {
if (!is.character(name)) { name <- deparse(substitute(name)) }
test <- function(env,name) is.element(name,ls(env)) && is.function(env[[`name`]])
if (test(env,name)) return(env[[`name`]])
if (isTRUE(inherits)) {
while (!identical(env,emptyenv())) {
env <- parent.env(env)
if (test(env,name)) return(env[[`name`]])
}
}
warning(paste(name," not found"))
NULL
}
fget('mean',globalenv())
fget('start',globalenv())
existsModified<- function(name, env = parent.frame(), inherits = FALSE) {
if (!is.character(name)) { name <- deparse(substitute(name)) }
if (!inherits) return(name %in% ls(env))
if (identical(env, emptyenv())) {
# base case
FALSE
} else if (name %in% ls(env)) {
# success case
TRUE
} else {
# recursive case
existsModified(name, env = parent.env(env), inherits = TRUE)
}
}
myExists('start')
existsModified('start')
existsModified('get')
existsModified('fget')
strModified<- function(name) {
list(
name = deparse(substitute(name))
callEnviron = parent.frame()
enclosEnviron = parent.env(environment())
)
}
strModified<- function(name) {
list(
name = deparse(substitute(name)),
callEnviron = parent.frame(),
enclosEnviron = parent.env(environment())
)
}
myStr(var)
strModified(var)
strModified(plot)
strModified(plot)
strModified<- function(name) {
list(
name = deparse(substitute(name)),
callEnviron = parent.frame(name),
enclosEnviron = parent.env(environment(name))
)
}
strModified(plot)
strModified<- function(name) {
name = deparse(substitute(name))
list(
functionname = name,
callEnviron = parent.frame(),
enclosEnviron = parent.env(environment())
)
}
strModified(var)
strModified<- function(name) {
name = deparse(substitute(name))
list(
functionname = name,
callEnviron = parent.frame(name),
enclosEnviron = parent.env(environment())
)
}
strModified(var)
strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = parent.frame(name),
enclosEnviron = parent.env(environment())
)
}
strModified(var)
parent.frame(var)
?parent.frame
strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = get("name", parent.frame()),
enclosEnviron = get("name", environment())
)
}
strModified(var)
strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = get(name, parent.frame()),
enclosEnviron = get(name, environment())
)
}
strModified(var)
strModified(mean)
strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = get(name, parent.frame()),
enclosEnviron = get(name, parent.env(environment()))
)
}
strModified(mean)
strModified(mean)
strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = parent.frame(),
enclosEnviron = get(name, parent.env(environment()))
)
}
strModified(mean)
?Reserved
rebind <- function(name, value, env = parent.frame()) {
if (identical(env, emptyenv())) {
stop("Can't find ", name, call. = FALSE)
} else if (exists(name, envir = env, inherits = FALSE)) {
assign(name, value, envir = env)
} else {
rebind(name, value, parent.env(env))
}
}
rebind("a", 10)
assignModified<- function(name, value, env = parent.frame()) {
if (exists(name, envir = env, inherits = FALSE)) {
stop("Name already exists ", name, call. = FALSE)
} else {
assign(name, value, env)
}
}
assignModified("a", 2)
a
assignModified("a", 3)
assignModified<- function(name, value, env = parent.frame()) {
if (exists(name, envir = env, inherits = FALSE)) {
stop("Name already exists ", call. = FALSE)
} else {
assign(name, value, env)
}
}
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
message2error <- function(code) {
withCallingHandlers(code, message = function(e) stop(e))
}
message2error
message2error <- function(code) {
tryCatch(code, message = function(e) stop(e))
}
message2error
message2error()
message2error(a)
rm(a)
message2error(a)
message2error <- function(code) {
withCallingHandlers(code, message = function(e) stop(e))
}
message2error(someCode)
message2error(someCode)
traceback()
message2error <- function(code) {
tryCatch(code, message = function(e) stop(e))
}
message2error(someCode)
try({
a <- 1
b <- "x"
a + b
})
col_means <- function(df) {
numeric <- sapply(df, is.numeric)
numeric_cols <- df[, numeric]
data.frame(lapply(numeric_cols, mean))
}
col_means(mtcars)
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(as.list(mtcars))
col_means(mtcars)
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(as.list(mtcars))
mtcars2 <- mtcars
mtcars2[-1] <- lapply(mtcars2[-1], as.character)
col_means(mtcars2)
col_means(mtcars[0, ])
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, 0])
col_means(mtcars[, 0])
col_means(mtcars[, 0])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(mtcars2)
col_means2 <- function(df) {
if (!is.data.frame(df)) stop("Input must be a data frame")
if (0 %in% dim(df)) {
warning("Dataframe is empty, no means to calculate.")
return(NULL)
}
numeric <- sapply(df, is.numeric)
if (FALSE %in% numeric) warning("Dropped ", sum(!numeric), " non-numeric columns.")
numeric_cols <- df[, numeric, drop = FALSE]
data.frame(lapply(numeric_cols, mean))
}
lag <- function(x, n = 1L) {
if (!is.numeric(n) | length(n) != 1)
stop('n must be a numeric vector with at least length 1.')
xlen <- length(x)
if (n > xlen) stop('n must be smaller than the number of elements in x')
if (n == 0)
warning('n is 0, so the lagged vector and the unlagged vector will be identical.')
c(rep(NA, n), x[seq_len(xlen - n)])
}
lag(seq(4), c(1, 2))
lag_(seq(4), 0)
lag(seq(4), 0)
match.fun(mean)
lapply(mtcars, function(x) sd(x)/mean(x))
integrate(function(x) x ^ 2 - x, 0, 10)
-pi
integrate(function(x) exp(x) / x, 10, 20)
integrate(exp(x) / x, 10, 20)
?approxfun()
library(e1071)
x <- runif(100)
moment(x, order=1, center=TRUE)
stopifnot(all.equal(-3.108624e-17, 0))
stopifnot(all.equal(-3, 0))
moment(x, order=2, center=TRUE)
var(x) * 99 / 100
method(moment)
methods(moment)
?moment
showMethods(moment)
getMethod(moment)
getMethod('moment')
getAnywhere(moment)
moment(x, order=1, center=TRUE)
mean(x)
x-mean(x)
moment<-function(momentOrder) {
function (x) (sum((x-mean(x))^momentOrder)/length(x))
}
m1 <- moment(1)
m2 <- moment(2)
x <- runif(100)
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
m1
m2
unenclose(m1)
library(pryr)
unenclose(m1)
unenclose(m2)
pick <- function(i) { function(x) x[[i]] }
lapply(mtcars, pick(5))
lapply(mtcars, function(x) x[[5]])
make_summary <- function(funs) {
function(x) {
lapply(funs, function(sf) sf(x))
}
}
summaryFuns <- c(mean, median, sd, mad, IQR)
summary2 <- make_summary(summaryFuns)
summary2(1:10)
summaryFuns <- list('min' = min, 'median' = median, 'mean' = mean, 'max' = max)
summary2 <- make_summary(summaryFuns)
summary2(1:10)
x <- 1:10
funs <- list(
sum = sum,
mean = mean,
median = median
)
lapply(funs, function(f) f(x, na.rm = TRUE))
x <- 1:10
funs <- list(
sum = sum,
mean = mean,
median = median
)
lapply(funs, function(f) f(x))
newton_cotes <- function(coef, open = FALSE) {
n <- length(coef) + open
function(f, a, b) {
pos <- function(i) a + i * (b - a) / n
points <- pos(seq.int(0, length(coef) - 1))
(b - a) / sum(coef) * sum(f(points) * coef)
}
}
boole <- newton_cotes(c(7, 32, 12, 32, 7))
milne <- newton_cotes(c(2, -1, 2), open = TRUE)
composite <- function(f, a, b, n = 10, rule) {
points <- seq(a, b, length = n + 1)
area <- 0
for (i in seq_len(n)) {
area <- area + rule(f, points[i], points[i + 1])
}
area
}
composite(sin, 0, pi, n = 10, rule = milne)
newton_cotes <- function(coef, open = FALSE) {
n <- length(coef) + open
function(f, a, b) {
pos <- function(i) a + i * (b - a) / n
points <- pos(seq.int(0, length(coef) - 1))
(b - a) / sum(coef) * sum(f(points) * coef)
}
}
rules <- list(
midpoint=list(coef = c(0, 1), open=TRUE),
trapezoid=list(coef=c(1,1)),
simpson=list(coef=c(1, 4, 1)),
boole=list(coef=c(7, 32, 12, 32, 7)),
milne=list(coef=c(2, -1, 2), open = TRUE))
lapply(rules, function(args) do.call('newton_cotes',
args))
lapply(rules, function(args) newton_cotes(args))
lapply(rules, function(args) newton_cotes(args))
lapply(rules, function(args) do.call('newton_cotes',args)))
lapply(rules, function(args) do.call('newton_cotes',args))
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
library(pryr)
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
composite(sin, 0, pi, n=10, rule = rules$midpoint)
composite(sin, 0, pi, n=10, rule = functionRules$midpoint)
functionRules<-lapply(rules, function(args) do.call('newton_cotes',args))
composite(sin, 0, pi, n=10, rule = functionRules$midpoint)
lapply(rules, function(r) composite(sin, 0, pi, n = 10, rule = r))
lapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
sapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
results<-sapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
results
