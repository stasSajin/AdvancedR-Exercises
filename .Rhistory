strModified<- function(name) {
name <- deparse(substitute(name))
list(
functionname = name,
callEnviron = parent.frame(),
enclosEnviron = get(name, parent.env(environment()))
)
}
strModified(mean)
?Reserved
rebind <- function(name, value, env = parent.frame()) {
if (identical(env, emptyenv())) {
stop("Can't find ", name, call. = FALSE)
} else if (exists(name, envir = env, inherits = FALSE)) {
assign(name, value, envir = env)
} else {
rebind(name, value, parent.env(env))
}
}
rebind("a", 10)
assignModified<- function(name, value, env = parent.frame()) {
if (exists(name, envir = env, inherits = FALSE)) {
stop("Name already exists ", name, call. = FALSE)
} else {
assign(name, value, env)
}
}
assignModified("a", 2)
a
assignModified("a", 3)
assignModified<- function(name, value, env = parent.frame()) {
if (exists(name, envir = env, inherits = FALSE)) {
stop("Name already exists ", call. = FALSE)
} else {
assign(name, value, env)
}
}
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)
message2error <- function(code) {
withCallingHandlers(code, message = function(e) stop(e))
}
message2error
message2error <- function(code) {
tryCatch(code, message = function(e) stop(e))
}
message2error
message2error()
message2error(a)
rm(a)
message2error(a)
message2error <- function(code) {
withCallingHandlers(code, message = function(e) stop(e))
}
message2error(someCode)
message2error(someCode)
traceback()
message2error <- function(code) {
tryCatch(code, message = function(e) stop(e))
}
message2error(someCode)
try({
a <- 1
b <- "x"
a + b
})
col_means <- function(df) {
numeric <- sapply(df, is.numeric)
numeric_cols <- df[, numeric]
data.frame(lapply(numeric_cols, mean))
}
col_means(mtcars)
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(as.list(mtcars))
col_means(mtcars)
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(as.list(mtcars))
mtcars2 <- mtcars
mtcars2[-1] <- lapply(mtcars2[-1], as.character)
col_means(mtcars2)
col_means(mtcars[0, ])
col_means(mtcars[, 0])
col_means(mtcars[0, ])
col_means(mtcars[, 0])
col_means(mtcars[, 0])
col_means(mtcars[, 0])
col_means(mtcars[, "mpg", drop = F])
col_means(1:10)
col_means(1:10)
col_means(as.matrix(mtcars))
col_means(mtcars2)
col_means2 <- function(df) {
if (!is.data.frame(df)) stop("Input must be a data frame")
if (0 %in% dim(df)) {
warning("Dataframe is empty, no means to calculate.")
return(NULL)
}
numeric <- sapply(df, is.numeric)
if (FALSE %in% numeric) warning("Dropped ", sum(!numeric), " non-numeric columns.")
numeric_cols <- df[, numeric, drop = FALSE]
data.frame(lapply(numeric_cols, mean))
}
lag <- function(x, n = 1L) {
if (!is.numeric(n) | length(n) != 1)
stop('n must be a numeric vector with at least length 1.')
xlen <- length(x)
if (n > xlen) stop('n must be smaller than the number of elements in x')
if (n == 0)
warning('n is 0, so the lagged vector and the unlagged vector will be identical.')
c(rep(NA, n), x[seq_len(xlen - n)])
}
lag(seq(4), c(1, 2))
lag_(seq(4), 0)
lag(seq(4), 0)
match.fun(mean)
lapply(mtcars, function(x) sd(x)/mean(x))
integrate(function(x) x ^ 2 - x, 0, 10)
-pi
integrate(function(x) exp(x) / x, 10, 20)
integrate(exp(x) / x, 10, 20)
?approxfun()
library(e1071)
x <- runif(100)
moment(x, order=1, center=TRUE)
stopifnot(all.equal(-3.108624e-17, 0))
stopifnot(all.equal(-3, 0))
moment(x, order=2, center=TRUE)
var(x) * 99 / 100
method(moment)
methods(moment)
?moment
showMethods(moment)
getMethod(moment)
getMethod('moment')
getAnywhere(moment)
moment(x, order=1, center=TRUE)
mean(x)
x-mean(x)
moment<-function(momentOrder) {
function (x) (sum((x-mean(x))^momentOrder)/length(x))
}
m1 <- moment(1)
m2 <- moment(2)
x <- runif(100)
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))
m1
m2
unenclose(m1)
library(pryr)
unenclose(m1)
unenclose(m2)
pick <- function(i) { function(x) x[[i]] }
lapply(mtcars, pick(5))
lapply(mtcars, function(x) x[[5]])
make_summary <- function(funs) {
function(x) {
lapply(funs, function(sf) sf(x))
}
}
summaryFuns <- c(mean, median, sd, mad, IQR)
summary2 <- make_summary(summaryFuns)
summary2(1:10)
summaryFuns <- list('min' = min, 'median' = median, 'mean' = mean, 'max' = max)
summary2 <- make_summary(summaryFuns)
summary2(1:10)
x <- 1:10
funs <- list(
sum = sum,
mean = mean,
median = median
)
lapply(funs, function(f) f(x, na.rm = TRUE))
x <- 1:10
funs <- list(
sum = sum,
mean = mean,
median = median
)
lapply(funs, function(f) f(x))
newton_cotes <- function(coef, open = FALSE) {
n <- length(coef) + open
function(f, a, b) {
pos <- function(i) a + i * (b - a) / n
points <- pos(seq.int(0, length(coef) - 1))
(b - a) / sum(coef) * sum(f(points) * coef)
}
}
boole <- newton_cotes(c(7, 32, 12, 32, 7))
milne <- newton_cotes(c(2, -1, 2), open = TRUE)
composite <- function(f, a, b, n = 10, rule) {
points <- seq(a, b, length = n + 1)
area <- 0
for (i in seq_len(n)) {
area <- area + rule(f, points[i], points[i + 1])
}
area
}
composite(sin, 0, pi, n = 10, rule = milne)
newton_cotes <- function(coef, open = FALSE) {
n <- length(coef) + open
function(f, a, b) {
pos <- function(i) a + i * (b - a) / n
points <- pos(seq.int(0, length(coef) - 1))
(b - a) / sum(coef) * sum(f(points) * coef)
}
}
rules <- list(
midpoint=list(coef = c(0, 1), open=TRUE),
trapezoid=list(coef=c(1,1)),
simpson=list(coef=c(1, 4, 1)),
boole=list(coef=c(7, 32, 12, 32, 7)),
milne=list(coef=c(2, -1, 2), open = TRUE))
lapply(rules, function(args) do.call('newton_cotes',
args))
lapply(rules, function(args) newton_cotes(args))
lapply(rules, function(args) newton_cotes(args))
lapply(rules, function(args) do.call('newton_cotes',args)))
lapply(rules, function(args) do.call('newton_cotes',args))
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
library(pryr)
unenclose(lapply(rules, function(args) do.call('newton_cotes',args)))
composite(sin, 0, pi, n=10, rule = rules$midpoint)
composite(sin, 0, pi, n=10, rule = functionRules$midpoint)
functionRules<-lapply(rules, function(args) do.call('newton_cotes',args))
composite(sin, 0, pi, n=10, rule = functionRules$midpoint)
lapply(rules, function(r) composite(sin, 0, pi, n = 10, rule = r))
lapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
sapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
results<-sapply(functionRules, function(r) composite(sin, 0, pi, n = 10, rule = r))
results
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(100)
x
lapply(trims, function(trim) mean(x, trim = trim))
lapply(trims, mean, x = x)
lapply(trims, mean, x = trims)
lapply(trims, mean, x = x, trims=0)
mean(x = c(0:10,50))
mean(0.5, x = c(0:10,50))
scale01 <- function(x) {
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
}
lapply(mtcars, scale01)
sapply(mtcars, scale01)
sapply(mtcars, function(x) { if (is.numeric(x)) scale01(x) else x })
lapply(formulas, lm, data = mtcars)
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
lapply(formulas, lm, data = mtcars)
sapply(formulas, lm, data = mtcars)
lapply(formulas, lm, data = mtcars)
formulas
for (i in length(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars);
}
for (i in length(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
output
}
output <- vector('list', length(formulas))
for (i in length(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
output
}
output
output <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
}
output
outputBoot <- lapply(bootstraps, lm, formula = mpg ~ disp)
bootstraps <- lapply(1:10, function(i) {
rows <- sample(1:nrow(mtcars), rep = TRUE)
mtcars[rows, ]
})
outputBoot <- lapply(bootstraps, lm, formula = mpg ~ disp)
outputBoot
output <- vector('list', length(bootstraps))
for (i in seq_along(bootstraps)) {
outputBoot[[i]] <- lm(mpg ~ disp, data = bootstraps[[i]])
}
outputBoot
unlist(lapply(output, rsq))
rsq <- function(mod) summary(mod)$r.squared
unlist(lapply(output, rsq))
lapply(output, rsq)
output <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
}
output
unlist(lapply(outputBoot, rsq))
unlist(lapply(output, rsq))
library(parallel)
boot_df <- function(x) x[sample(nrow(x), rep = T), ]
rsquared <- function(mod) summary(mod)$r.square
boot_lm <- function(i) {
rsquared(lm(mpg ~ wt + disp, data = boot_df(mtcars)))
}
system.time(lapply(1:500, boot_lm))
system.time(mclapply(1:500, boot_lm, mc.cores = 2))
vapply(mtcars, sd, numeric(1))
vapply(mtcars[vapply(mtcars, is.numeric, logical(1))], sd, numeric(1))
trials <- replicate(
100,
t.test(rpois(10, 10), rpois(7, 10)),
simplify = FALSE
)
trials
sapply(trials, function(x) x$p.avlue)
sapply(trials, function(test) test$p.avlue)
sapply(trials, function(x) x$p.value)
sapply(trials, `[[`, "p")
sapply(trials, `[[`, "p.value")
?replicate
?replicate
library(pryr)
?replicate
?replicate()
mcsapply <- function(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) {
FUN <- match.fun(FUN)
answer <- parallel::mclapply(X = X, FUN = FUN, ...)
if (USE.NAMES && is.character(X) && is.null(names(answer)))
names(answer) <- X
if (!identical(simplify, FALSE) && length(answer))
simplify2array(answer, higher = (simplify == "array"))
else answer
}
microbenchmark::microbenchmark(
mcsapply(seq(10), function(x) { Sys.sleep(0.1); x + 1 }, mc.cores = 4),
mcsapply(seq(10), function(x) { Sys.sleep(0.1); x + 1 }, mc.cores = 1)
, times = 1)
mcsapply <- function(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) {
FUN <- match.fun(FUN)
answer <- parallel::mclapply(X = X, FUN = FUN, ...)
if (USE.NAMES && is.character(X) && is.null(names(answer)))
names(answer) <- X
if (!identical(simplify, FALSE) && length(answer))
simplify2array(answer, higher = (simplify == "array"))
else answer
}
microbenchmark::microbenchmark(
mcsapply(seq(10), function(x) { Sys.sleep(0.1); x + 1 }, mc.cores = 1),
mcsapply(seq(10), function(x) { Sys.sleep(0.1); x + 1 }, mc.cores = 1)
, times = 1)
apply(mtcars, 2, mean)
str(apply(mtcars, 2, mean))
typeof(apply(mtcars, 2, mean))
a<-apply(mtcars, 2, mean)
is.data.frame(a)
is.vector(a)
pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
pieces <- split(pulse, group)
pieces
pulse
split_vapply <- function(x, f, FUN, FUN.VALUE, ...){
pieces <- split(x, f)
vapply(pieces, FUN = FUN, FUN.VALUE = FUN.VALUE, ...)
}
split_vapply(pulse, group, mean, numeric(1))
pulse
group
pieces
library(magrittr)
split2 <- function(x, f, drop = FALSE, ...) {
f %>% as.factor %>% unique %>%
lapply(., function(sf) x[f == sf, ]) %>%
{ names(.) <- levels(f); . }
}
split2(iris, iris$Species)
split2(mtcars, mtcars$cyl)
summary(mtcars, mean)
summary2(mtcars, mean)
summary2 <- function(df, f) {
vapply(Filter(df, is.numeric), f, numeric(1))
}
summary2(mtcars, mean)
summary2 <- function(df, f) {
vapply(Filter(is.numeric, df), f, numeric(1))
}
summary2(mtcars, mean)
scramble <- sample(1:5, size = 50, replace = TRUE)
Position(function(x) x == 1, scramble)
which(scramble == 1)
min(which(scramble == 1))
arg_max <- function(x, FUN) {
FUN.x <- vapply(x, FUN, numeric(1))
x[which(FUN.x == max(FUN.x))]
}
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
#using the lapply
lapply(formulas, lm, data = mtcars)
#using loops
output <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
}
output
bootstraps <- lapply(1:10, function(i) {
rows <- sample(1:nrow(mtcars), rep = TRUE)
mtcars[rows, ]
})
#with lapply(); should show the output of 10 bootstrapped models.
outputBoot <- lapply(bootstraps, lm, formula = mpg ~ disp)
outputBoot
#this time using a for loop
output <- vector('list', length(bootstraps))
for (i in seq_along(bootstraps)) {
outputBoot[[i]] <- lm(mpg ~ disp, data = bootstraps[[i]])
}
outputBoot
rsq <- function(mod) summary(mod)$r.squared
unlist(lapply(output, rsq))
unlist(lapply(outputBoot, rsq))
unlist(lapply(output, rsq))
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
#using the lapply
lapply(formulas, lm, data = mtcars)
#using loops
output2 <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
}
output2
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
#using the lapply
lapply(formulas, lm, data = mtcars)
#using loops
output2 <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output[[i]] <- lm(formulas[[i]], data = mtcars)
}
output2
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
#using the lapply
lapply(formulas, lm, data = mtcars)
#using loops
output2 <- vector('list', length(formulas))
for (i in seq_along(formulas)) {
output2[[i]] <- lm(formulas[[i]], data = mtcars)
}
output2
bootstraps <- lapply(1:10, function(i) {
rows <- sample(1:nrow(mtcars), rep = TRUE)
mtcars[rows, ]
})
#with lapply(); should show the output of 10 bootstrapped models.
outputBoot <- lapply(bootstraps, lm, formula = mpg ~ disp)
outputBoot
#this time using a for loop
output <- vector('list', length(bootstraps))
for (i in seq_along(bootstraps)) {
outputBoot[[i]] <- lm(mpg ~ disp, data = bootstraps[[i]])
}
outputBoot
rsq <- function(mod) summary(mod)$r.squared
unlist(lapply(output2, rsq))
unlist(lapply(outputBoot, rsq))
